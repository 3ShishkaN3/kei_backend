# Отчет по сервису `material_service`

## Обзор сервиса

Сервис `material_service` отвечает за управление различными типами учебных материалов (текст, изображения, аудио, видео, документы) и, что наиболее важно для данного отчета, за создание и обработку тестов, а также за прием и сохранение ответов студентов на эти тесты.

## Бизнес-логика тестов и механика проверки

### 1. Модели данных (`material_service/models.py`)

`models.py` определяет структуру тестов и их компонентов, а также механизм для сохранения ответов студентов.

*   **`Test`**: Основная модель для тестов. Имеет поле `test_type`, которое определяет тип теста:
    *   `mcq-multi`: Выбор нескольких ответов.
    *   `mcq-single`: Выбор одного ответа.
    *   `free-text`: Текстовый ответ.
    *   `word-order`: Правильный порядок слов.
    *   `drag-and-drop`: Перетаскивание элементов.
    *   `pronunciation`: Проверка произношения.
    *   `spelling`: Проверка правописания.
    Для `drag-and-drop` тестов предусмотрено поле `draggable_options_pool` для хранения всех доступных "облачков" (вариантов для перетаскивания).

*   **Специфичные модели для типов тестов**: Каждому типу теста соответствует своя модель, хранящая правильные ответы или эталонные данные:
    *   `MCQOption`: Содержит `is_correct` для вариантов MCQ.
    *   `FreeTextQuestion`: Имеет `reference_answer` для сверки.
    *   `WordOrderSentence`: Хранит `correct_ordered_texts` (правильный порядок слов).
    *   `MatchingPair` (переименована в `drag_drop_slots`): Содержит `correct_answer_text` для каждой ячейки.
    *   `PronunciationQuestion`: `text_to_pronounce` для задания.
    *   `SpellingQuestion`: `reference_spelling` для задания.

*   **`TestSubmission`**: Модель для записи факта отправки теста студентом. Ключевое поле `status` может принимать следующие значения:
    *   `submitted`: Отправлено (ожидает автопроверки/отправки на проверку).
    *   `grading_pending`: На проверке (требует ручной проверки или проверки ИИ).
    *   `graded`: Проверено.
    *   `auto_failed`: Автопроверка: Не пройдено.
    *   `auto_passed`: Автопроверка: Пройдено.

*   **Модели ответов студентов**: Отдельные модели (`MCQSubmissionAnswer`, `FreeTextSubmissionAnswer`, `WordOrderSubmissionAnswer`, `DragDropSubmissionAnswer`, `PronunciationSubmissionAnswer`, `SpellingSubmissionAnswer`) хранят фактические ответы студентов для каждого типа теста.

### 2. Сериализаторы (`material_service/serializers.py`)

`serializers.py` отвечает за валидацию и преобразование данных при создании/обновлении тестов и приеме ответов.

*   **`TestSerializer`**: Используется для создания и редактирования тестов, включая вложенные компоненты (варианты MCQ, вопросы со свободным текстом и т.д.).
*   **`TestSubmissionInputSerializer`**: **Ключевой сериализатор для приема ответов.**
    *   Он принимает `section_item_id` (для привязки к уроку) и `answers` (JSON-поле с ответами).
    *   Для тестов на произношение и правописание также принимает файлы (`submitted_audio_file`, `submitted_image_file`).
    *   Метод `validate_answers` динамически выбирает соответствующий сериализатор для валидации структуры ответов в зависимости от `test_type`.
    *   Проверяет, что выбранные опции MCQ принадлежат данному тесту, а для Drag-and-Drop — что `slot_id` и `dropped_option_text` соответствуют тесту.

### 3. Представления (`material_service/views.py`)

`views.py` содержит логику обработки HTTP-запросов, включая отправку тестов.

*   **`TestViewSet`**: Имеет кастомное действие `@action(detail=True, methods=['post']) submit`. Это основной эндпоинт для отправки ответов студентами.
*   **Логика в `submit` действии**:
    1.  **Получение данных**: Принимает данные через `TestSubmissionInputSerializer`.
    2.  **Определение начального статуса**:
        *   Для тестов типа `free-text`, `pronunciation`, `spelling` (которые требуют ручной проверки или проверки ИИ), статус `TestSubmission` устанавливается как `'grading_pending'`. Это соответствует концепции **отложенной механики проверки** и участия `admin_service` или нейросети.
        *   Для других типов (`mcq-single`, `mcq-multi`, `word-order`, `drag-and-drop`) статус устанавливается как `'submitted'`.
    3.  **Сохранение ответов**: Создается запись `TestSubmission` и соответствующие записи ответов (например, `MCQSubmissionAnswer`, `FreeTextSubmissionAnswer` и т.д.).
    4.  **Автоматическая проверка (частичная)**:
        *   Для тестов типа `drag-and-drop`, в процессе сохранения `DragDropSubmissionAnswer`, поле `is_correct` для каждого отдельного перетащенного элемента **сразу же вычисляется и сохраняется**. Это подтверждает **автоматизацию проверки для однозначных ответов** без участия преподавателя или ИИ.
        *   Для `mcq-single`, `mcq-multi`, `word-order` тестов, хотя `is_correct` не устанавливается напрямую в этом месте, их статус `submitted` и последующая отправка в Kafka подразумевают, что окончательная автоматическая проверка (`auto_passed`/`auto_failed`) будет происходить внешним сервисом.
    5.  **Интеграция с Kafka**: После успешного сохранения отправки теста, генерируется и отправляется событие `test_submitted` в Kafka-топик `'progress_events'`. Это событие содержит всю необходимую информацию о тесте, студенте и отправке. Это подтверждает ваше намерение использовать Kafka для взаимодействия с `progress_service` (который будет учитывать прогресс ученика) и, возможно, с `admin_service` для дальнейшей проверки.

### 4. Механизмы проверки

Исходя из анализа, механизмы проверки тестов спроектированы следующим образом:

*   **Автоматическая проверка (без участия преподавателя/ИИ)**:
    *   **Drag-and-Drop**: Проверка происходит **непосредственно в `material_service/views.py`** при сохранении ответа. Для каждого перетащенного элемента (`DragDropSubmissionAnswer`) сравнивается `dropped_option_text` с `correct_answer_text` соответствующей ячейки (`MatchingPair`), и результат сохраняется в поле `is_correct`.
    *   **MCQ (Single/Multi Choice), Word Order**: Ответы сохраняются со статусом `submitted`. Окончательная автоматическая оценка (`auto_passed`/`auto_failed`) для этих типов, вероятно, должна происходить в сервисе, который потребляет Kafka-события (`progress_service` или отдельный сервис автопроверки), так как `material_service` не устанавливает эти статусы напрямую.

*   **Отложенная проверка (с участием преподавателя/ИИ)**:
    *   **Free-text, Pronunciation, Spelling**: При отправке этих тестов статус `TestSubmission` устанавливается как `grading_pending`. Это явно указывает на необходимость внешней проверки.
    *   **Роль Kafka**: Событие `test_submitted` отправляется в Kafka для *всех* типов тестов. Это центральный механизм для уведомления других сервисов (`progress_service`, `admin_service`, потенциально сервис с нейросетью) о новой отправке.
        *   `progress_service` будет использовать эти события для отслеживания прогресса студента.
        *   `admin_service` или отдельный сервис с нейросетью, вероятно, будут потреблять эти события для выполнения отложенной проверки тестов со статусом `grading_pending` (free-text, pronunciation, spelling). После проверки они должны будут обновить статус `TestSubmission` на `graded`, `auto_passed` или `auto_failed` и, возможно, добавить `score` и `feedback`.

### 5. Рекомендации и дальнейшие шаги

Ваша архитектура хорошо продумана для разделения ответственности и асинхронной обработки.

*   **Для MCQ и Word Order**: Убедитесь, что `progress_service` (или другой сервис-потребитель Kafka) содержит логику для автоматической проверки этих типов тестов на основе `selected_option_ids` (для MCQ) и `submitted_order_words` (для Word Order) по сравнению с эталонными ответами в `material_service`. После проверки этот сервис должен будет обновить статус `TestSubmission` на `auto_passed` или `auto_failed` и, возможно, проставить `score`.
*   **Для Free-text, Pronunciation, Spelling**: Разработайте логику в `admin_service` или отдельном сервисе (возможно, с использованием нейросети) для обработки `grading_pending` submissions. Этот сервис будет получать данные из Kafka, извлекать ответы (текст, аудио, изображение), выполнять проверку (ручную или с помощью ИИ) и затем обновлять `TestSubmission` в `material_service` (через API или прямой доступ к БД, если это часть одного монолита или микросервисы имеют общую БД) с финальным статусом, оценкой и обратной связью.
*   **Тестирование**: Поскольку `material_service/tests.py` пуст, крайне рекомендуется добавить юнит- и интеграционные тесты для:
    *   Создания и обновления всех типов тестов.
    *   Отправки ответов для каждого типа теста, включая проверку валидации.
    *   Проверки корректности установки `is_correct` для `drag-and-drop` ответов.
    *   Проверки отправки Kafka-событий.
    *   Проверки начальных статусов `TestSubmission` (`submitted` vs `grading_pending`).

Эта структура позволяет `material_service` оставаться относительно "легким" в плане логики проверки, делегируя сложные или длительные процессы другим специализированным сервисам через Kafka.
